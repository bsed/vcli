// Copyright 2016 Sisa-Tech Pty Ltd
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package compiler

import (
	"errors"
	"io/ioutil"
	"os"
	"strconv"

	"github.com/sisatech/sherlock"
)

// TODO: proper xml generation, rather than this hack
const (
	ovfA = `<?xml version="1.0" encoding="UTF-8"?>
<!--Generated by VMware VirtualCenter Server, User: root, UTC time: 2016-08-11T09:13:41.494638Z-->
<Envelope vmw:buildId="build-3721164" xmlns="http://schemas.dmtf.org/ovf/envelope/1" xmlns:cim="http://schemas.dmtf.org/wbem/wscim/1/common" xmlns:ovf="http://schemas.dmtf.org/ovf/envelope/1" xmlns:rasd="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData" xmlns:vmw="http://www.vmware.com/schema/ovf" xmlns:vssd="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_VirtualSystemSettingData" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <References>
    <File ovf:chunkSize="7516192768" ovf:href="`
	ovfB = `" ovf:id="file1" ovf:size="`
	ovfC = `"/>
</References>
<DiskSection>
<Info>Virtual disk information</Info>
<Disk ovf:capacity="`
	ovfD = `" ovf:capacityAllocationUnits="byte * 2^20" ovf:diskId="vmdisk1" ovf:fileRef="file1" ovf:format="http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized" ovf:populatedSize="`
	ovfE = `"/>
</DiskSection>
<NetworkSection>
<Info>The list of logical networks</Info>
<Network ovf:name="VM Network">
  <Description>The VM Network network</Description>
</Network>
</NetworkSection>
<VirtualSystem ovf:id="vO-App-1">
<Info>A virtual machine</Info>
<Name>vO-App-1</Name>
<OperatingSystemSection ovf:id="101" vmw:osType="otherLinux64Guest">
  <Info>The kind of installed guest operating system</Info>
  <Description>Other Linux (64-bit)</Description>
</OperatingSystemSection>
<VirtualHardwareSection>
  <Info>Virtual hardware requirements</Info>
  <System>
    <vssd:ElementName>Virtual Hardware Family</vssd:ElementName>
    <vssd:InstanceID>0</vssd:InstanceID>
    <vssd:VirtualSystemIdentifier>vO-App-1</vssd:VirtualSystemIdentifier>
    <vssd:VirtualSystemType>vmx-10</vssd:VirtualSystemType>
  </System>
  <Item>
    <rasd:AllocationUnits>hertz * 10^6</rasd:AllocationUnits>
    <rasd:Description>Number of Virtual CPUs</rasd:Description>
    <rasd:ElementName>2 virtual CPU(s)</rasd:ElementName>
    <rasd:InstanceID>1</rasd:InstanceID>
    <rasd:ResourceType>3</rasd:ResourceType>
    <rasd:VirtualQuantity>2</rasd:VirtualQuantity>
  </Item>
  <Item>
    <rasd:AllocationUnits>byte * 2^20</rasd:AllocationUnits>
    <rasd:Description>Memory Size</rasd:Description>
    <rasd:ElementName>384MB of memory</rasd:ElementName>
    <rasd:InstanceID>2</rasd:InstanceID>
    <rasd:ResourceType>4</rasd:ResourceType>
    <rasd:VirtualQuantity>384</rasd:VirtualQuantity>
  </Item>
  <Item>
    <rasd:Address>0</rasd:Address>
    <rasd:Description>SATA Controller</rasd:Description>
    <rasd:ElementName>SATA controller 0</rasd:ElementName>
    <rasd:InstanceID>3</rasd:InstanceID>
    <rasd:ResourceSubType>vmware.sata.ahci</rasd:ResourceSubType>
    <rasd:ResourceType>20</rasd:ResourceType>
    <vmw:Config ovf:required="false" vmw:key="slotInfo.pciSlotNumber" vmw:value="34"/>
  </Item>
  <Item ovf:required="false">
       <rasd:AutomaticAllocation>true</rasd:AutomaticAllocation>
       <rasd:ElementName>serial0</rasd:ElementName>
       <rasd:InstanceID>5</rasd:InstanceID>
       <rasd:ResourceType>21</rasd:ResourceType>
       <vmw:Config ovf:required="false" vmw:key="yieldOnPoll" vmw:value="false"/>
  </Item>
  <Item ovf:required="false">
    <rasd:AutomaticAllocation>false</rasd:AutomaticAllocation>
    <rasd:ElementName>Video card</rasd:ElementName>
    <rasd:InstanceID>6</rasd:InstanceID>
    <rasd:ResourceType>24</rasd:ResourceType>
    <vmw:Config ovf:required="false" vmw:key="enable3DSupport" vmw:value="false"/>
    <vmw:Config ovf:required="false" vmw:key="use3dRenderer" vmw:value="automatic"/>
    <vmw:Config ovf:required="false" vmw:key="useAutoDetect" vmw:value="false"/>
    <vmw:Config ovf:required="false" vmw:key="videoRamSizeInKB" vmw:value="4096"/>
  </Item>
  <Item ovf:required="false">
    <rasd:AutomaticAllocation>false</rasd:AutomaticAllocation>
    <rasd:ElementName>VMCI device</rasd:ElementName>
    <rasd:InstanceID>7</rasd:InstanceID>
    <rasd:ResourceSubType>vmware.vmci</rasd:ResourceSubType>
    <rasd:ResourceType>1</rasd:ResourceType>
    <vmw:Config ovf:required="false" vmw:key="allowUnrestrictedCommunication" vmw:value="false"/>
    <vmw:Config ovf:required="false" vmw:key="slotInfo.pciSlotNumber" vmw:value="33"/>
  </Item>
  <Item>
    <rasd:AddressOnParent>0</rasd:AddressOnParent>
    <rasd:ElementName>Hard disk 1</rasd:ElementName>
    <rasd:HostResource>ovf:/disk/vmdisk1</rasd:HostResource>
    <rasd:InstanceID>9</rasd:InstanceID>
    <rasd:Parent>3</rasd:Parent>
    <rasd:ResourceType>17</rasd:ResourceType>
    <vmw:Config ovf:required="false" vmw:key="backing.writeThrough" vmw:value="false"/>
  </Item>
  <Item>
    <rasd:AddressOnParent>7</rasd:AddressOnParent>
    <rasd:AutomaticAllocation>true</rasd:AutomaticAllocation>
    <rasd:Connection>VM Network</rasd:Connection>
    <rasd:Description>E1000 ethernet adapter on &quot;VM Network&quot;</rasd:Description>
    <rasd:ElementName>Network adapter 1</rasd:ElementName>
    <rasd:InstanceID>11</rasd:InstanceID>
    <rasd:ResourceSubType>E1000</rasd:ResourceSubType>
    <rasd:ResourceType>10</rasd:ResourceType>
    <vmw:Config ovf:required="false" vmw:key="slotInfo.pciSlotNumber" vmw:value="32"/>
    <vmw:Config ovf:required="false" vmw:key="wakeOnLanEnabled" vmw:value="true"/>
  </Item>
  <vmw:Config ovf:required="false" vmw:key="cpuHotAddEnabled" vmw:value="false"/>
  <vmw:Config ovf:required="false" vmw:key="cpuHotRemoveEnabled" vmw:value="false"/>
  <vmw:Config ovf:required="false" vmw:key="firmware" vmw:value="bios"/>
  <vmw:Config ovf:required="false" vmw:key="virtualICH7MPresent" vmw:value="false"/>
  <vmw:Config ovf:required="false" vmw:key="virtualSMCPresent" vmw:value="false"/>
  <vmw:Config ovf:required="false" vmw:key="memoryHotAddEnabled" vmw:value="false"/>
  <vmw:Config ovf:required="false" vmw:key="nestedHVEnabled" vmw:value="false"/>
  <vmw:Config ovf:required="false" vmw:key="powerOpInfo.powerOffType" vmw:value="soft"/>
  <vmw:Config ovf:required="false" vmw:key="powerOpInfo.resetType" vmw:value="soft"/>
  <vmw:Config ovf:required="false" vmw:key="powerOpInfo.standbyAction" vmw:value="checkpoint"/>
  <vmw:Config ovf:required="false" vmw:key="powerOpInfo.suspendType" vmw:value="hard"/>
  <vmw:Config ovf:required="false" vmw:key="tools.afterPowerOn" vmw:value="true"/>
  <vmw:Config ovf:required="false" vmw:key="tools.afterResume" vmw:value="true"/>
  <vmw:Config ovf:required="false" vmw:key="tools.beforeGuestShutdown" vmw:value="true"/>
  <vmw:Config ovf:required="false" vmw:key="tools.beforeGuestStandby" vmw:value="true"/>
  <vmw:Config ovf:required="false" vmw:key="tools.syncTimeWithHost" vmw:value="false"/>
  <vmw:Config ovf:required="false" vmw:key="tools.toolsUpgradePolicy" vmw:value="manual"/>
</VirtualHardwareSection>
</VirtualSystem>
</Envelope>`
)

// BuildOVF returns the name of a compiled .ovf disk image within a temporary
// folder. The caller should move the file to a non-temporary location.
func BuildOVF(binary, config, files, kernel string, debug bool) (string, error) {

	err := FullValidation(binary, config, files, "", kernel)
	if err != nil {
		return "", err
	}

	// TODO: implement

	return "", errors.New("unimplemented")

}

func generateOVF(path, diskSize string) (*os.File, error) {
	var err error
	var ovf string
	var f *os.File

	err = sherlock.Try(func() {

		var name string
		var size, expandedSize string
		info, err := os.Stat(path)
		sherlock.Check(err)
		name = info.Name()
		expandedSize = strconv.FormatInt(info.Size(), 10)
		// determine size of stream optimized vmdk
		info, err = os.Stat(path)
		sherlock.Check(err)
		size = strconv.FormatInt(info.Size(), 10)
		ovf = ovfA + name + ovfB + size + ovfC + diskSize + ovfD + expandedSize + ovfE
		f, err = ioutil.TempFile("", "")
		sherlock.Check(err)
		f.Close()
		err = os.Rename(f.Name(), f.Name()+".ovf")
		sherlock.Check(err)
		sherlock.Check(ioutil.WriteFile(f.Name()+".ovf", []byte(ovf), 0666))
		f, err = os.Open(f.Name() + ".ovf")
		sherlock.Check(err)

	})

	return f, err
}
